{"meta":{"title":"shuzhouliu's blog","subtitle":"","description":"","author":"Shuzhou Liu","url":"https://blog.shuzhouliu.bio","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2022-11-27T02:11:34.022Z","updated":"2022-11-27T02:11:34.022Z","comments":false,"path":"/404.html","permalink":"https://blog.shuzhouliu.bio/404.html","excerpt":"","text":""},{"title":"关于","date":"2022-11-27T02:11:34.022Z","updated":"2022-11-27T02:11:34.022Z","comments":false,"path":"about/index.html","permalink":"https://blog.shuzhouliu.bio/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"分类","date":"2022-11-27T02:11:34.022Z","updated":"2022-11-27T02:11:34.022Z","comments":false,"path":"categories/index.html","permalink":"https://blog.shuzhouliu.bio/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2022-11-27T02:11:34.022Z","updated":"2022-11-27T02:11:34.022Z","comments":true,"path":"links/index.html","permalink":"https://blog.shuzhouliu.bio/links/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2022-11-27T02:11:34.022Z","updated":"2022-11-27T02:11:34.022Z","comments":false,"path":"repository/index.html","permalink":"https://blog.shuzhouliu.bio/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2022-11-27T02:11:34.022Z","updated":"2022-11-27T02:11:34.022Z","comments":false,"path":"tags/index.html","permalink":"https://blog.shuzhouliu.bio/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"AtCoder Beginner Contest 279题解","slug":"abc279","date":"2022-11-26T23:13:00.000Z","updated":"2022-11-27T02:11:34.022Z","comments":true,"path":"2022/11/26/abc279/","link":"","permalink":"https://blog.shuzhouliu.bio/2022/11/26/abc279/","excerpt":"","text":"A. wwwvvvvvv由题意得 w 和 v “bottoms” 的个数分别为 和 ，所以累加即可。 12345678910#include&lt;bits/stdc++.h&gt;using namespace std;string s;int main() { cin &gt;&gt; s; long long ans = 0; for (auto i:s) ans += (i=='v'?1:2); cout &lt;&lt; ans &lt;&lt; endl; return 0;} 时间复杂度 。 B. LOOKUPstd::string 中的类函数 find 可以用来查找子串，返回子串第一次出现的位置，如果不存在则返回 std::string::npos，可以解决本题。 12345678#include&lt;bits/stdc++.h&gt;using namespace std;string s, t;int main() { cin &gt;&gt; s &gt;&gt; t; cout &lt;&lt; (s.find(t) == string::npos ? \"No\" : \"Yes\") &lt;&lt; endl; return 0;} C. RANDOM大致题意：给定二维的字符数组 和 ，若 的列的任意排列能够变成 ，则输出 Yes，否则输出 No。 由于 的列的任意排列能够变成 ，所以 的每一列都必须在 中出现，且每一列出现的次数必须相同。 误区：不可以统计每列 # 的个数（本质上是一种哈希），因为 # 的个数可能相同，但是每列的 # 的位置不同。 错误代码（两个数据点WA）： 12345678910111213141516171819202122#include&lt;bits/stdc++.h&gt;using namespace std;int h, w;vector&lt;string&gt; s, t;vector&lt;int&gt; sc, tc;int main() { cin &gt;&gt; h &gt;&gt; w; s.resize(h), t.resize(h); for (auto &amp;i:s) cin &gt;&gt; i; for (auto &amp;i:t) cin &gt;&gt; i; sc.resize(w), tc.resize(w); for (int i = 0; i &lt; w; i++) { for (int j = 0; j &lt; h; j++) { sc[i] += s[j][i] == '#'; tc[i] += t[j][i] == '#'; } } sort(sc.begin(), sc.end()); sort(tc.begin(), tc.end()); cout &lt;&lt; (sc == tc ? \"Yes\" : \"No\") &lt;&lt; endl; return 0;} 于是容易想到记录这一列的字符串，于是这道题就可以通过了。时间复杂度 。 123456789101112131415161718192021222324#include&lt;bits/stdc++.h&gt;using namespace std;int h, w;vector&lt;string&gt; s, t;vector&lt;string&gt; cs, ct;int main() { cin &gt;&gt; h &gt;&gt; w; s.resize(h), t.resize(h); for (auto &amp;i:s) cin &gt;&gt; i; for (auto &amp;i:t) cin &gt;&gt; i; cs.resize(w), ct.resize(w); for (int i = 0; i &lt; w; i++) { cs[i].resize(h); ct[i].resize(h); for (int j = 0; j &lt; h; j++) { cs[i][j] = s[j][i]; ct[i][j] = t[j][i]; } } sort(cs.begin(), cs.end()); sort(ct.begin(), ct.end()); cout &lt;&lt; (cs == ct ? \"Yes\" : \"No\") &lt;&lt; endl; return 0;} D. Freefall大致题意：求 在 上的最小值。 不难得到原函数的定义域是 ，且原函数是一个单峰函数。于是我们可以在 上求 的最小值，然后再将 和 的值求最小值输出。 故而本题可以求导解决，时间复杂度 。 已知 ，则易得 ，令 ，则有 ，于是我们就可以求得 在 的最小值，从而求出其在 上的最小值。 123456789101112131415#include&lt;bits/stdc++.h&gt;using namespace std;long long a, b;long double sq (long double x) { return x*x; }int main() { cin &gt;&gt; a &gt;&gt; b; long double x = (cbrt(2) - 2*sq(cbrt(b*1.0/a))) / (2*sq(cbrt(b*1.0/a))); long double ans; long long x0; x0 = floor(x); ans = (long double) b * x0 + a * 1.0 / sqrt(x0+1); x0 = ceil(x); ans = min(ans, (long double) b * x0 + a * 1.0 / sqrt(x0+1)); cout &lt;&lt; fixed &lt;&lt; setprecision(30) &lt;&lt; ans &lt;&lt; endl; return 0;}","categories":[{"name":"题解","slug":"题解","permalink":"https://blog.shuzhouliu.bio/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"AtCoder","slug":"AtCoder","permalink":"https://blog.shuzhouliu.bio/tags/AtCoder/"}]},{"title":"AtCoder Beginner Contest 277 题解","slug":"abc277","date":"2022-11-12T23:05:31.000Z","updated":"2022-11-27T02:11:34.022Z","comments":true,"path":"2022/11/12/abc277/","link":"","permalink":"https://blog.shuzhouliu.bio/2022/11/12/abc277/","excerpt":"","text":"A. ^{-1}由于本题给定的 是一个 的排列，所以不存在 中两数相同，直接判断即可。 1234567891011#include&lt;bits/stdc++.h&gt;using namespace std;int n, x;int main() { scanf(\"%d%d\", &amp;n, &amp;x); for (int i = 1, a; i &lt;= n; i++) { scanf(\"%d\", &amp;a); if (a == x) printf(\"%d\\n\", i), exit(0); } return 0;} B. Playing Cards Validation本题的重点是判断输入的牌是否合法。题目给出： 字符串的第一个字符是 H、D、C 或 S。 字符串的第二个字符是 到 之间的数字，或 T、J、Q 或 K。 保证字符串的长度为 。 故而可以写出判断： 1234567bool check (string s) { auto i = s[0]; if (i != 'H' &amp;&amp; i != 'D' &amp;&amp; i != 'S' &amp;&amp; i != 'C') return false; i = s[1]; if (i != '2' &amp;&amp; i != '3' &amp;&amp; i != '4' &amp;&amp; i != '5' &amp;&amp; i != '6' &amp;&amp; i != '7' &amp;&amp; i != '8' &amp;&amp; i != '9' &amp;&amp; i != 'T' &amp;&amp; i != 'J' &amp;&amp; i != 'Q' &amp;&amp; i != 'K' &amp;&amp; i != 'A') return false; return true;} 题目要求输入的牌两两不相同，可以利用 std::set 来判断是否唯一。 12345678910111213141516171819202122232425#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 53;int n;string s;set&lt;string&gt; st;bool check (string s) { auto i = s[0]; if (i != 'H' &amp;&amp; i != 'D' &amp;&amp; i != 'S' &amp;&amp; i != 'C') return false; i = s[1]; if (i != '2' &amp;&amp; i != '3' &amp;&amp; i != '4' &amp;&amp; i != '5' &amp;&amp; i != '6' &amp;&amp; i != '7' &amp;&amp; i != '8' &amp;&amp; i != '9' &amp;&amp; i != 'T' &amp;&amp; i != 'J' &amp;&amp; i != 'Q' &amp;&amp; i != 'K' &amp;&amp; i != 'A') return false; return true;}int main() { cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) { cin &gt;&gt; s; st.insert(s); if (!check(s)) puts(\"No\"), exit(0); } if (st.size() == n) puts(\"Yes\"); else puts(\"No\"); return 0;} C. Ladder Takahashi本题需要求的是最大的可达高度。故而我们可以先记录Takahashi可以到达的高度，然后输出最大的一个即可。 可以看作一个图，以每次给定的 连双向边。然后从 开始DFS，记录能到达的最大高度。 123456void dfs (int u) { vst[u] = true; for (auto v: es[u]) if (!vst.count(v)) dfs(v);} 我们可以使用 std::map 代替离散化，即定义 map&lt;int, vector&lt;int&gt;&gt; es 作为邻接表，如此可以省去一些时间。 由于 std::map 对 _Key 具有有序性，故而我们可以在第三个模板参数中从默认的 std::less&lt;_Key&gt; 改为 std::greater&lt;_Key&gt;，如此便可以访问到 std::map 中的最大值。 12345678910111213141516171819202122#include&lt;bits/stdc++.h&gt;using namespace std;map&lt;int, vector&lt;int&gt;&gt; es;map&lt;int, bool, greater&lt;int&gt;&gt; vst;int n;void dfs (int u) { vst[u] = true; for (auto v: es[u]) if (!vst.count(v)) dfs(v);}int main() { cin &gt;&gt; n; for (int i = 1, a, b; i &lt;= n; i++) { cin &gt;&gt; a &gt;&gt; b; es[a].push_back(b); es[b].push_back(a); } dfs(1); printf(\"%d\\n\", vst.begin()-&gt;first); return 0;} D. Takahashi’s Solitaire本题可以移除连续的数字段，故而可以先对题目给定的 进行排序。然后我们可以枚举每次数字段的起始点 。 排序后，我们令 ，这样就可以在 赋值 是 的情况下统一处理，减少条件判断。 注意此处不可以写 a[r]-a[r-1]%m &lt;= 1，这样会导致负值从而WA。 计算完 的情况后可以直接退出，因为 的情况下连续串的长度一定最大，且 在枚举范围中是单调的。 1234567891011121314151617181920212223242526#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 200001;typedef long long ll;int n, m, a[N];ll sum = 0;int main() { cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i], sum += a[i]; sort(a+1, a+n+1); a[0] = a[n]; ll ans = sum; for (int l = 1; l &lt;= n; l++) { ll cur = a[l], r = l+1; while (r &lt;= n &amp;&amp; a[r]-a[r-1] &lt;= 1) cur += a[r], r++; ans = min(ans, sum-cur); if (r == n+1) { r = 1; while (r &lt; l &amp;&amp; (a[r] == a[r-1]%m || a[r] == (a[r-1]+1) % m)) cur += a[r], r++; ans = min(ans, sum-cur); break; } l = r-1; } cout &lt;&lt; ans &lt;&lt; endl; return 0;}","categories":[{"name":"题解","slug":"题解","permalink":"https://blog.shuzhouliu.bio/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"AtCoder","slug":"AtCoder","permalink":"https://blog.shuzhouliu.bio/tags/AtCoder/"}]}],"categories":[{"name":"题解","slug":"题解","permalink":"https://blog.shuzhouliu.bio/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"AtCoder","slug":"AtCoder","permalink":"https://blog.shuzhouliu.bio/tags/AtCoder/"}]}