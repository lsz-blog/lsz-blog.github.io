---
title: 动态规划
date: 2022-10-15 19:41:06
tags:
  - 动态规划
  - oi
category: 笔记
mathjax: true
toc: true
---

动态规划是一种通过把原问题分解为**相对**简单的子问题的方式求解复杂问题的方法。

一般来说，子问题需要含有以下性质：

+ 子问题范围更小且个数有限。

+ 目标值具有最优子结构。

+ 无后效性：子问题的解不会影响其他子问题的解。

动态规划常用来解决最优化问题和计数问题。

## 动态规划基础

一般，在动态规划中，我们有以下概念定义：

+ 状态：某种规模问题的一个值，例如“$f_i$ 表示以第 $i$ 个元素结尾的LIS的长度“ 中 $f_i$ 就是状态。

+ 状态转移方程：状态之间的转移关系，例如LIS问题中，$f_i$ 的状态转移方程为 $f_i=\max(f_j+1|a_j<a_i)$。

+ 初始状态：每个问题的初始值。例如LIS问题中，每个元素自身都是一个LIS，因此初始状态为 $f_i=1$。

+ 边界条件：问题的边界值。

+ 答案：问题的最终答案。

## 入门问题

### LIS

LIS（Longest Increasing Subsequence）问题是动态规划的入门问题，其定义为：给定一个序列 $a_1,a_2,\cdots,a_n$，求一个最长的子序列，使得这个子序列中的每个元素都比前一个元素大。

例如，对于序列 $1,2,3,4,10,6,7,8,9$，其LIS为 $1,2,3,4,6,7,8,9$，长度为8。

于是我们可以考虑状态定义了。

设 $f_i$ 表示以第 $i$ 个元素结尾的LIS的长度，那么我们可以得到状态转移方程：

$$
f_i=\max(f_j+1|a_j<a_i)
$$

其中 $j<i$。

初始状态为 $f_i=1$。

```c++
for (int i = 1; i <= n; i++) {
    f[i] = 1;
    for (int j = 1; j < i; j++)
        if (a[j] < a[i])
            f[i] = max(f[i], f[j]+1);
}
printf("%d\n", *max_element(f+1, f+n+1));
```

答案并不是 $f_n$，而是 $\max f_i$，因为不取 $a_n$ 也可能是一个LIS。

时间复杂度 $O(n^2)$。但是LIS问题可以用二分优化到 $O(n\log n)$。

本来是很麻烦的，但是有了 `lower_bound` 之后就很简单了。

### LCS

LCS（Longest Common Subsequence）是动态规划的入门问题，其定义为：给定两个序列 $a_1,a_2,\cdots,a_n$ 和 $b_1,b_2,\cdots,b_m$，求一个最长的子序列，使得这个子序列中的每个元素都在两个序列中都出现过。

例如，对于序列 $1,2,3,4,10,6,7,8,9$ 和 $1,2,3,4,5,6,7,8,9$，其LCS为 $1,2,3,4,6,7,8,9$，长度为8。

于是我们可以考虑状态定义了。

令 $f_{i, j}$ 表示 $a_1 \cdots a_i$ 和 $b_1 \cdots b_j$ 的LCS长度。

首先，显然 $f_{0, 0}=0$。

那么，对于每个 $f_{i, j}$，我们可以考虑两种情况：

+ $a_i = b_j$，则 $f_{i, j} = f_{i-1, j-1} + 1$。

+ $a_i \neq b_j$，则 $f_{i, j} = \max(f_{i-1, j}, f_{i, j-1})$。

```c++
for (int i = 1; i <= n; i++)
    for (int j = 1; j <= m; j++) {
        if (a[i] == b[j])
            f[i][j] = f[i-1][j-1] + 1;
        else
            f[i][j] = max(f[i-1][j], f[i][j-1]);
    }
printf("%d\n", f[n][m]);
```

最后的答案显然是 $f_{n, m}$，其中 $n$ 和 $m$ 分别是两个序列的长度。

## 背包问题

### 01背包

01背包问题的定义为：给定 $n$ 件物品和一个容量为 $V$ 的背包。物品 $i$ 的重量是 $w_i$，价值是 $v_i$。问应该如何选择装入背包的物品，使得装入背包中的物品总价值最大？

例如，对于 $n=4, V=5$，物品重量为 $2, 1, 3, 2$，价值为 $3, 2, 4, 2$，最优解为 $3+2+2=7$。

于是我们可以考虑状态定义了。

定义 $f_{i, j}$ 表示前 $i$ 个物品放入容量为 $j$ 的背包的最大价值。

显然 $f_{0, 0} = 0$，因为没有物品放入容量为0的背包中肯定价值为0。

那么，对于每个 $f_{i, j}$，我们可以考虑两种情况：

+ 不放第 $i$ 个物品，即 $f_{i, j} = f_{i-1, j}$。

+ 放第 $i$ 个物品，即 $f_{i, j} = f_{i-1, j-w_i} + v_i$。

那么两者取最大值即可。

```c++
for (int i = 1; i <= n; i++)
    for (int j = w[i]; j <= V; j++)
        f[i][j] = max(f[i-1][j], f[i-1][j-w[i]] + v[i]);
```

此处第二层循环下界为 $w_i$，因为我们要保证 $j-w_i \geq 0$。

最后的答案显然是 $f_{n, V}$。

但是有的时候，空间会不够，我们需要 $O(nV)$ 的空间，但是有的时候 $nV$ 会很大，这时候我们可以考虑滚动数组。

我们可以先将 $f_{i,j}$ 等去掉一维，分别为 $f_{j}$、$f_{j}$、$f_{j-w_i}$。

那么我们每轮还原回去，会发现 $f_{j-w_i}$ 是 $f_{i,j-w_i}$，所以应该第二维从后往前，这样才能保证 $f_{j-w_i}$ 是 $f_{i-1,j-w_i}$。

```c++
for (int i = 1; i <= n; i++)
    for (int j = V; j >= w[i]; j--)
        f[j] = max(f[j], f[j-w[i]] + v[i]);
```

### 完全背包

完全背包问题的定义为：给定 $n$ 种物品和一个容量为 $V$ 的背包。物品 $i$ 的重量是 $w_i$，价值是 $v_i$。问应该如何选择装入背包的物品，使得装入背包中的物品总价值最大？每种物品的数量是无限的。

于是我们可以考虑状态定义了。

定义 $f_{i, j}$ 表示前 $i$ 种物品放入容量为 $j$ 的背包的最大价值。

同理 $f_{0, 0} = 0$，因为没有物品放入容量为0的背包中肯定价值为0。

那么，对于每个 $f_{i, j}$，我们可以考虑两种情况：

+ 不放第 $i$ 种物品，即 $f_{i, j} = f_{i-1, j}$。

+ 放第 $i$ 种物品，即 $f_{i, j} = f_{i, j-w_i} + v_i$。

两者取最大值即可。

```c++
for (int i = 1; i <= n; i++)
    for (int j = w[i]; j <= V; j++)
        f[i][j] = max(f[i-1][j], f[i][j-w[i]] + v[i]);
```

空间复杂度 $O(nV)$。同理，我们可以滚动数组将空间优化至 $O(V)$。

```c++
for (int i = 1; i <= n; i++)
    for (int j = w[i]; j <= V; j++)
        f[j] = max(f[j], f[j-w[i]] + v[i]);
```

### 多重背包

> 提示：代码仅供参考，输入顺序可能和例题有所区别。

多重背包问题的定义为：给定 $n$ 种物品和一个容量为 $V$ 的背包。物品 $i$ 的重量是 $w_i$，价值是 $v_i$。问应该如何选择装入背包的物品，使得装入背包中的物品总价值最大？每种物品的数量是有限的，即 $c_i$ 个。

朴素的办法就是把第 $i$ 个物品拆分成 $c_i$ 个物品，然后用01背包的方法来解决。时间复杂度 $O(\sum c_i V)$，其中 $\sum c_i$ 表示所有 $c_i$ 之和。显然，例如对于每个 $c_i \sim 10^5$ 的情况，大概率就不行了。

```c++
const int N = 1000001;
int n, V, w[N], v[N], c[N], cnt, nw[N], nv[N], f[N];
int main() {
    scanf("%d%d", &n, &V);
    for (int i = 1; i <= n; i++) {
        scanf("%d%d%d", &w[i], &v[i], &c[i]);
        for (int j = 1; j <= c[i]; j++) {
            nw[++cnt] = w[i];
            nv[cnt] = v[i];
        }
    }
    for (int i = 1; i <= cnt; i++)
        for (int j = V; j >= nw[i]; j--)
            f[j] = max(f[j], f[j-nw[i]] + nv[i]);
    printf("%d\n", f[V]);
}
```

#### 二进制拆分优化

于是我们引入二进制优化的思想，将每个物品拆分成若干个物品，使得每个物品的数量都是 $2^k$，这样就可以用01背包的方法来解决了。

时间复杂度是 $O(\sum \log c_i V)$。对于 $\sum c_i \sim 10^9$ 的情况，表现也不错。

例如：有 $c_i = 5$，而 $(5)_{10} = (101)_2$。所以可以分拆成 $2^0 + 2^2$ 个物品。

```c++
const int N = 1000001;
int n, V, w[N], v[N], c[N], cnt, nw[N], nv[N], f[N];
int main() {
    scanf("%d%d", &n, &V);
    for (int i = 1; i <= n; i++) {
        scanf("%d%d%d", &w[i], &v[i], &c[i]);
        for (int k = 1; k <= c[i]; k <<= 1) {
            nw[++cnt] = w[i] * k;
            nv[cnt] = v[i] * k;
            c[i] -= k;
        }
        if (c[i]) {
            nw[++cnt] = w[i] * c[i];
            nv[cnt] = v[i] * c[i];
        }
    }
    for (int i = 1; i <= cnt; i++)
        for (int j = V; j >= nw[i]; j--)
            f[j] = max(f[j], f[j-nw[i]] + nv[i]);
    printf("%d\n", f[V]);
}
```

模板题：[Luogu P1776 宝物筛选](https://www.luogu.com.cn/problem/P1776)，注意输入顺序有区别。

#### 单调队列优化

考虑优化 $f_j$ 的转移。朴素的状态转移方程是 $f_{i, j} = \max_{k=0}^{c_i}(f_{i-1,j-kw_i} + kv_i)$，时间复杂度 $O(\sum c_i V)$。

令 $g_{x,y} = f_{i,xw_i+y}$，$g^{'}_{x,y} = f_{i-1,xw_i+y}$，则

$$
g_{x,y}= \max_{k=0}^{c_i}(g'_{x-k,y} + kv_i)
$$

令 $G_{x,y} = g'{x,y} - xv_i$，则方程可转化为：

$$
g_{x,y} = \max_{k=0}^{c_i}(G_{x-k,y} + xv_i)
$$

便是经典的单调队列优化形式。所以求出所有 $g_{x,y}$ 复杂度为 $O(\lfloor\dfrac{V}{w_i}\rfloor)\times O(w_i)=O(V)$，则总复杂度 $O(nW)$。

### 混合背包

> 混合背包就是把01背包、完全背包、多重背包混合在一起，可以取 $1$ 次，有穷次或无穷次。

伪代码：

```peudocode
for i = 1 to n
    if type[i] == 1
        do 01_knapsack
    else if type[i] == 2
        do complete_knapsack
    else
        do multi_knapsack
```

例题：[Luogu P1833 樱花](https://www.luogu.com.cn/problem/P1833)

