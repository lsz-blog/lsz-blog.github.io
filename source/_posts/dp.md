---
title: 动态规划
date: 2022-10-15 19:41:06
tags:
  - 动态规划
  - oi
category: 笔记
mathjax: true
toc: true
---

动态规划是一种通过把原问题分解为**相对**简单的子问题的方式求解复杂问题的方法。

一般来说，子问题需要含有以下性质：

+ 子问题范围更小且个数有限。

+ 目标值具有最优子结构。

+ 无后效性：子问题的解不会影响其他子问题的解。

动态规划常用来解决最优化问题和计数问题。

## 动态规划基础

一般，在动态规划中，我们有以下概念定义：

+ 状态：某种规模问题的一个值，例如“$f_i$ 表示以第 $i$ 个元素结尾的LIS的长度“ 中 $f_i$ 就是状态。

+ 状态转移方程：状态之间的转移关系，例如LIS问题中，$f_i$ 的状态转移方程为 $f_i=\max(f_j+1|a_j<a_i)$。

+ 初始状态：每个问题的初始值。例如LIS问题中，每个元素自身都是一个LIS，因此初始状态为 $f_i=1$。

+ 边界条件：问题的边界值。

+ 答案：问题的最终答案。

## 入门问题

### LIS

LIS（Longest Increasing Subsequence）问题是动态规划的入门问题，其定义为：给定一个序列 $a_1,a_2,\cdots,a_n$，求一个最长的子序列，使得这个子序列中的每个元素都比前一个元素大。

例如，对于序列 $1,2,3,4,10,6,7,8,9$，其LIS为 $1,2,3,4,6,7,8,9$，长度为8。

于是我们可以考虑状态定义了。

设 $f_i$ 表示以第 $i$ 个元素结尾的LIS的长度，那么我们可以得到状态转移方程：

$$
f_i=\max(f_j+1|a_j<a_i)
$$

其中 $j<i$。

初始状态为 $f_i=1$。

```c++
for (int i = 1; i <= n; i++) {
    f[i] = 1;
    for (int j = 1; j < i; j++)
        if (a[j] < a[i])
            f[i] = max(f[i], f[j]+1);
}
printf("%d\n", *max_element(f+1, f+n+1));
```

答案并不是 $f_n$，而是 $\max f_i$，因为不取 $a_n$ 也可能是一个LIS。

时间复杂度 $O(n^2)$。但是LIS问题可以用二分优化到 $O(n\log n)$。

本来是很麻烦的，但是有了 `lower_bound` 之后就很简单了。

### LCS

LCS（Longest Common Subsequence）是动态规划的入门问题，其定义为：给定两个序列 $a_1,a_2,\cdots,a_n$ 和 $b_1,b_2,\cdots,b_m$，求一个最长的子序列，使得这个子序列中的每个元素都在两个序列中都出现过。

例如，对于序列 $1,2,3,4,10,6,7,8,9$ 和 $1,2,3,4,5,6,7,8,9$，其LCS为 $1,2,3,4,6,7,8,9$，长度为8。

于是我们可以考虑状态定义了。

令 $f_{i, j}$ 表示 $a_1 \cdots a_i$ 和 $b_1 \cdots b_j$ 的LCS长度。

首先，显然 $f_{0, 0}=0$。

那么，对于每个 $f_{i, j}$，我们可以考虑两种情况：

+ $a_i = b_j$，则 $f_{i, j} = f_{i-1, j-1} + 1$。

+ $a_i \neq b_j$，则 $f_{i, j} = \max(f_{i-1, j}, f_{i, j-1})$。

```c++
for (int i = 1; i <= n; i++)
    for (int j = 1; j <= m; j++) {
        if (a[i] == b[j])
            f[i][j] = f[i-1][j-1] + 1;
        else
            f[i][j] = max(f[i-1][j], f[i][j-1]);
    }
printf("%d\n", f[n][m]);
```

最后的答案显然是 $f_{n, m}$，其中 $n$ 和 $m$ 分别是两个序列的长度。

## 背包问题

### 01背包

01背包问题的定义为：给定 $n$ 件物品和一个容量为 $V$ 的背包。物品 $i$ 的重量是 $w_i$，价值是 $v_i$。问应该如何选择装入背包的物品，使得装入背包中的物品总价值最大？

例如，对于 $n=4, V=5$，物品重量为 $2, 1, 3, 2$，价值为 $3, 2, 4, 2$，最优解为 $3+2+2=7$。

于是我们可以考虑状态定义了。

定义 $f_{i, j}$ 表示前 $i$ 个物品放入容量为 $j$ 的背包的最大价值。

显然 $f_{0, 0} = 0$，因为没有物品放入容量为0的背包中肯定价值为0。

那么，对于每个 $f_{i, j}$，我们可以考虑两种情况：

+ 不放第 $i$ 个物品，即 $f_{i, j} = f_{i-1, j}$。

+ 放第 $i$ 个物品，即 $f_{i, j} = f_{i-1, j-w_i} + v_i$。

那么两者取最大值即可。

```c++
for (int i = 1; i <= n; i++)
    for (int j = w[i]; j <= V; j++)
        f[i][j] = max(f[i-1][j], f[i-1][j-w[i]] + v[i]);
```

此处第二层循环下界为 $w_i$，因为我们要保证 $j-w_i \geq 0$。

最后的答案显然是 $f_{n, V}$。

但是有的时候，空间会不够，我们需要 $O(nV)$ 的空间，但是有的时候 $nV$ 会很大，这时候我们可以考虑滚动数组。

我们可以先将 $f_{i,j}$ 等去掉一维，分别为 $f_{j}$、$f_{j}$、$f_{j-w_i}$。

那么我们每轮还原回去，会发现 $f_{j-w_i}$ 是 $f_{i,j-w_i}$，所以应该第二维从后往前，这样才能保证 $f_{j-w_i}$ 是 $f_{i-1,j-w_i}$。

```c++
for (int i = 1; i <= n; i++)
    for (int j = V; j >= w[i]; j--)
        f[j] = max(f[j], f[j-w[i]] + v[i]);
```

### 完全背包

完全背包问题的定义为：给定 $n$ 种物品和一个容量为 $V$ 的背包。物品 $i$ 的重量是 $w_i$，价值是 $v_i$。问应该如何选择装入背包的物品，使得装入背包中的物品总价值最大？每种物品的数量是无限的。

于是我们可以考虑状态定义了。

定义 $f_{i, j}$ 表示前 $i$ 种物品放入容量为 $j$ 的背包的最大价值。

同理 $f_{0, 0} = 0$，因为没有物品放入容量为0的背包中肯定价值为0。

那么，对于每个 $f_{i, j}$，我们可以考虑两种情况：

+ 不放第 $i$ 种物品，即 $f_{i, j} = f_{i-1, j}$。

+ 放第 $i$ 种物品，即 $f_{i, j} = f_{i, j-w_i} + v_i$。

两者取最大值即可。

```c++
for (int i = 1; i <= n; i++)
    for (int j = w[i]; j <= V; j++)
        f[i][j] = max(f[i-1][j], f[i][j-w[i]] + v[i]);
```

空间复杂度 $O(nV)$。同理，我们可以滚动数组将空间优化至 $O(V)$。

```c++
for (int i = 1; i <= n; i++)
    for (int j = w[i]; j <= V; j++)
        f[j] = max(f[j], f[j-w[i]] + v[i]);
```

